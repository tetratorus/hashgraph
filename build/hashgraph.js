// Generated by CoffeeScript 1.10.0
(function() {
  var circles, delay, draw, eventWidth, height, machineHeight, makeMachine, names, paddingLeft, topOffset, width;

  window.Visualizer = {
    machines: []
  };

  Visualizer.addMachine = function(node) {
    return Visualizer.machines.push(node);
  };

  Visualizer.sendMessage = function(fromMachine, toMachine, message, duration) {
    var fromX, fromY, messageCircle, onArrive, toX, toY;
    if (duration == null) {
      duration = 1000 + Math.random() * 2000;
    }
    onArrive = function() {
      toMachine.receiveMessage(message, fromMachine);
      draw();
      return messageCircle.remove();
    };
    toX = toMachine.position.left + toMachine.dimensions.width / 2;
    toY = toMachine.position.top + 6;
    fromX = fromMachine.position.left + fromMachine.dimensions.width / 2;
    fromY = fromMachine.position.top + 6;
    messageCircle = Visualizer.circle(fromX, fromY, 15);
    messageCircle.animate({
      transform: ["T", toX - fromX, toY - fromY]
    }, duration);
    return delay(duration, onArrive);
  };

  makeMachine = function(name, nodes) {
    var canSee, canStronglySee, consensus, determineRound, divideRounds, events, findEvent, getLastEventFrom, gossip, knownMachines, machine, receiveMessage;
    machine = {};
    knownMachines = {};
    events = [];
    gossip = function() {
      var event, eventsToSend, i, len, randomName, receiver;
      if (Object.keys(knownMachines).length === 1) {
        return alert("Dont know any machines. Cant gossip");
      }
      while (!(receiver && receiver.name !== name)) {
        randomName = Object.keys(knownMachines)[Math.floor(Math.random() * Object.keys(knownMachines).length)];
        receiver = knownMachines[randomName];
      }
      eventsToSend = [];
      for (i = 0, len = events.length; i < len; i++) {
        event = events[i];
        eventsToSend.push({
          node: event.node,
          hash: event.hash,
          parentHash: event.parentHash,
          time: event.time,
          fromHash: event.fromHash
        });
      }
      return Visualizer.sendMessage(machine, receiver, JSON.stringify(eventsToSend));
    };
    receiveMessage = function(message) {
      var event, fromNodeName, i, j, k, learnedSomething, len, len1, len2, newEvent, old, possibleMachine, receivedEvent, receivedEvents, ref;
      receivedEvents = JSON.parse(message);
      learnedSomething = false;
      for (i = 0, len = receivedEvents.length; i < len; i++) {
        receivedEvent = receivedEvents[i];
        old = false;
        fromNodeName = receivedEvent.node;
        if (!knownMachines[fromNodeName]) {
          ref = Visualizer.machines;
          for (j = 0, len1 = ref.length; j < len1; j++) {
            possibleMachine = ref[j];
            if (possibleMachine.name === fromNodeName) {
              knownMachines[fromNodeName] = possibleMachine;
            }
          }
        }
        for (k = 0, len2 = events.length; k < len2; k++) {
          event = events[k];
          if (event.hash === receivedEvent.hash) {
            old = true;
            break;
          }
        }
        if (old) {
          continue;
        }
        events.push(receivedEvent);
        receivedEvent.selfParent = findEvent(receivedEvent.parentHash);
        receivedEvent.otherParent = findEvent(receivedEvent.fromHash);
        learnedSomething = true;
      }
      if (!learnedSomething) {
        return;
      }
      newEvent = {
        node: machine.name,
        hash: Math.random(),
        parentHash: getLastEventFrom(name).hash,
        fromHash: getLastEventFrom(fromNodeName).hash,
        time: new Date()
      };
      events.push(newEvent);
      return consensus();
    };
    getLastEventFrom = function(nodeName) {
      var event, i, lastEvent, len;
      lastEvent = null;
      for (i = 0, len = events.length; i < len; i++) {
        event = events[i];
        if (event.node === nodeName) {
          lastEvent = event;
        }
      }
      return lastEvent;
    };
    findEvent = function(hash) {
      var event, i, len;
      for (i = 0, len = events.length; i < len; i++) {
        event = events[i];
        if (event.hash === hash) {
          return event;
        }
      }
    };
    consensus = function() {
      return divideRounds();
    };
    divideRounds = function() {
      var i, len, results, x;
      results = [];
      for (i = 0, len = events.length; i < len; i++) {
        x = events[i];
        if (x.round) {
          continue;
        }
        results.push(determineRound(x));
      }
      return results;
    };
    determineRound = function(x) {
      var parent1, parent2, see, stronglySee;
      if (!x.parentHash) {
        x.round = 1;
        x.witness = true;
        return;
      }
      parent1 = findEvent(x.parentHash);
      if (!parent1.round) {
        determineRound(parent1);
      }
      parent2 = findEvent(y.fromHash);
      if (!parent2.round) {
        determineRound(parent2);
      }
      see = [];
      stronglySee = [];
      return x.witness = x.round > findEvent(x.parentHash).round && x.round > findEvent(x.fromHash).round;
    };
    canStronglySee = function(x, y) {};
    canSee = function(x, y) {
      if ((x.parentHash === y.hash) || (x.fromHash === y.hash)) {
        return true;
      }
      if (!x.parentHash) {
        return false;
      }
      return canSee(findEvent(x.parentHash), y) || canSee(findEvent(x.fromHash), y);
    };
    Object.assign(machine, {
      name: name,
      gossip: gossip,
      receiveMessage: receiveMessage,
      events: events,
      knownMachines: knownMachines,
      findEvent: findEvent
    });
    events.push({
      node: machine.name,
      hash: Math.random(),
      time: new Date(),
      txs: ['createme']
    });
    return machine;
  };

  height = 800;

  machineHeight = 220;

  width = 600;

  eventWidth = 30;

  topOffset = 20;

  paddingLeft = 150;

  circles = {};

  draw = function() {
    var circle, event, eventIndex, eventX, fromEvent, i, index, knownMachine, len, machine, machineAngle, machineIndex, machineWidth, machineX, machineY, name, path, rect, ref, ref1, results, text, timelineStartY;
    ref = Visualizer.machines;
    results = [];
    for (machineIndex = i = 0, len = ref.length; i < len; machineIndex = ++i) {
      machine = ref[machineIndex];
      if (machine.set) {
        machine.set.remove();
      }
      machine.set = Visualizer.set();
      machineAngle = machineIndex * 2 * Math.PI / Visualizer.machines.length;
      machineWidth = Object.keys(machine.knownMachines).length * eventWidth + eventWidth;
      machineX = (1 + Math.cos(-machineAngle - Math.PI)) * width / 2 - eventWidth - machineWidth / 2 + paddingLeft;
      machineY = (1 + Math.sin(-machineAngle)) * (height - machineHeight) / 2;
      machine.position = {
        left: machineX,
        top: machineY
      };
      machine.dimensions = {
        width: machineWidth,
        height: machineHeight
      };
      rect = Visualizer.rect(machineX, machineY + topOffset, machineWidth, machineHeight);
      rect.attr({
        stroke: '#ccc',
        fill: '#fafafa'
      });
      machine.set.push(rect);
      text = Visualizer.text(machineX + machineWidth / 2, machineY + 8, machine.name);
      machine.set.push(text);
      timelineStartY = machineY + machineHeight - 20;
      index = 0;
      ref1 = machine.knownMachines;
      for (name in ref1) {
        knownMachine = ref1[name];
        path = Visualizer.path("M " + (machineX + eventWidth + index * eventWidth) + "," + timelineStartY + " l 0," + (-machineHeight + topOffset + 20));
        path.attr({
          stroke: '#333'
        });
        machine.set.push(path);
        text = Visualizer.text(machineX + eventWidth + index * eventWidth, machineY + machineHeight, name);
        machine.set.push(text);
        index += 1;
      }
      results.push((function() {
        var j, len1, ref2, results1;
        ref2 = machine.events;
        results1 = [];
        for (eventIndex = j = 0, len1 = ref2.length; j < len1; eventIndex = ++j) {
          event = ref2[eventIndex];
          eventX = machineX + eventWidth + Object.keys(machine.knownMachines).indexOf(event.node) * eventWidth;
          circle = Visualizer.circle(eventX, timelineStartY - 22 * eventIndex, 10);
          circle.attr("fill", "#EEE");
          circle.attr("stroke", "#333");
          if (event.fromHash) {
            fromEvent = machine.findEvent(event.fromHash);
            if (fromEvent && circles[fromEvent.hash]) {
              path = "M " + (circles[fromEvent.hash].attr('cx')) + "," + (circles[fromEvent.hash].attr('cy')) + " L " + (circle.attr('cx')) + " " + (circle.attr('cy'));
              machine.set.push(Visualizer.path(path));
            }
          }
          circles[event.hash] = circle;
          results1.push(machine.set.push(circle));
        }
        return results1;
      })());
    }
    return results;
  };

  names = ['Alice', 'Bob', 'Charly', 'Dan', 'Eve', 'Fred', 'Gus', 'Henry', 'Ivy', 'Jim'];

  $(function() {
    Visualizer.__proto__ = Raphael(document.getElementById('hashgraph_visualizer'));
    $('button#add_node').click(function() {
      var i, len, machine, name, newMachine, ref;
      name = names[Visualizer.machines.length];
      newMachine = makeMachine(name);
      Visualizer.addMachine(newMachine);
      ref = Visualizer.machines;
      for (i = 0, len = ref.length; i < len; i++) {
        machine = ref[i];
        newMachine.knownMachines[machine.name] = machine;
      }
      draw();
      $('#log')[0].innerHTML += name + " initialized with " + (Object.keys(newMachine.knownMachines).length) + " nodes.\n";
      return $("<button>Make " + name + " gossip</button>").appendTo($('#gossips')).click(function() {
        return newMachine.gossip();
      });
    });
    $('button#add_node').click();
    return $('button#add_node').click();
  });

  delay = function(t, fn) {
    return setTimeout(fn, t);
  };

}).call(this);
